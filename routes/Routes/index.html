<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">routes</a> &#x00BB; Routes</nav><h1>Module <code>Routes</code></h1><p>Typed routing for OCaml. <code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime.</p></header><div class="spec module" id="module-Method"><a href="#module-Method" class="anchor"></a><code><span class="keyword">module</span> <a href="Method/index.html">Method</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p><code>'a t</code> represents a path parameter of type 'a.</p></dd></dl><dl><dt class="spec type" id="type-router"><a href="#type-router" class="anchor"></a><code><span class="keyword">type</span> <span>'a router</span></code></dt><dd><p><code>'a router</code> represents the internal router data type, where each route can potentially return a value of type 'a .</p></dd></dl><dl><dt class="spec value" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span class="keyword">val</span> pattern : <span>(string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pattern convert label</code> allows the creation of custom param matchers. This allows creating matchers for custom types so the router can be extended to use types beyond the ones that ship with the library.</p><p>The provided label will be used when pretty printing routes, or when converting a route to a human readable string pattern.</p><p>Example:</p><pre><code class="ml">(* This pattern matches any integer *)
let int = pattern int_of_string_opt &quot;&lt;int&gt;&quot;

let bool = pattern bool_of_string_opt &quot;&lt;bool&gt;&quot;</code></pre><dl><dt>since</dt><dd>0.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return v</code> is a path param parser that always returns v.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>apply f t</code> applies a function f that is wrapped inside a <code>'a t</code> context to a path param parser. f &lt;*&gt; p is the same as f &gt;&gt;= fun f -&gt; map ~f p</p><p>Example:</p><pre><code class="ml">let add = a + b (* int -&gt; int -&gt; int *)

let add' = return add (* (int -&gt; int -&gt; int) t *)

apply add' int (* (int -&gt; int) t *)</code></pre></dd></dl><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val</span> s : string <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>s word</code> returns a path parser that matches <code>word</code> exactly and then discards the result.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int</code> parses a path parmeter and succeeds if its an integer.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span>int32 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int32</code> parses a path parameter and succeeds if its a valid 32 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span>int64 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int64</code> parses a path parameter and succeeds if its a valid 64 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bool</code> parses a path parameter and succeeds if its either &quot;true&quot; or &quot;false&quot;.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>str</code> parses a path param and returns it as a string.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> matches an empty target. This can be used to match against &quot;/&quot;.</p></dd></dl><dl><dt class="spec value" id="val-one_of"><a href="#val-one_of" class="anchor"></a><code><span class="keyword">val</span> one_of : <span>?&#8288;ignore_trailing_slash:bool</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>one_of</code> accepts a list of route parsers and converts into a router. ignore_trailing_slash is a boolean flag that can control whether to keep or ignore the trailing slash in the input target url. The default value is true.</p></dd></dl><dl><dt class="spec value" id="val-with_method"><a href="#val-with_method" class="anchor"></a><code><span class="keyword">val</span> with_method : <span>?&#8288;ignore_trailing_slash:bool</span> <span>&#45;&gt;</span> <span><span>(<a href="Method/index.html#type-t">Method.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>with_method</code> accepts a list of routes + http methods and converts it into a router. This will also group methods based on the Http verb. If there are multiple route definitions that overlap and are potential matches, the one defined first will be returned.</p><p>ignore_trailing_slash is a boolean flag that can control whether to keep or ignore the trailing slash in the input target url. The default value is true.</p></dd></dl><dl><dt class="spec value" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span class="keyword">val</span> match' : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>match'</code> runs the router against the provided target url.</p></dd></dl><dl><dt class="spec value" id="val-match_with_method"><a href="#val-match_with_method" class="anchor"></a><code><span class="keyword">val</span> match_with_method : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span>target:string</span> <span>&#45;&gt;</span> <span>meth:<a href="Method/index.html#type-t">Method.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>match_with_method</code> is used to run the router. It accepts a target url string, HTTP method verb a request of any type (which is forwarded as the last parameter to the handler functions). If a route matches it runs the attached handler and returns the result.</p></dd></dl><dl><dt class="spec value" id="val-get_route_patterns"><a href="#val-get_route_patterns" class="anchor"></a><code><span class="keyword">val</span> get_route_patterns : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span><span>(<a href="Method/index.html#type-t">Method.t</a> * string)</span> list</span></code></dt><dd><p><code>get_route_patterns</code> returns a list of human readable route patterns that will be matched by a router.</p><dl><dt>since</dt><dd>0.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pattern_of_route"><a href="#val-pattern_of_route" class="anchor"></a><code><span class="keyword">val</span> pattern_of_route : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>pattern_of_route</code> convert a route to a human readable string pattern.</p><dl><dt>since</dt><dd>0.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_route"><a href="#val-pp_route" class="anchor"></a><code><span class="keyword">val</span> pp_route : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><dl><dt>since</dt><dd>0.6.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_router"><a href="#val-pp_router" class="anchor"></a><code><span class="keyword">val</span> pp_router : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><dl><dt>since</dt><dd>0.6.0</dd></dl></dd></dl><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Routes_private"><a href="#module-Routes_private" class="anchor"></a><code><span class="keyword">module</span> <a href="Routes_private/index.html">Routes_private</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>